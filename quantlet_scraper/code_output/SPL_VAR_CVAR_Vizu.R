# -----------------------------------------------------------------------------
# Quantlet No. 5 : Plot Quantlet
#
# This quantlet covers the respective plots of the quantlets 2 to 4, namely the
# VaR &amp; CVaR quantlet, the Testing quantlet and the Portfolio Optimization 
# quantlet. All plots are generated by means of the R function 'ggplot' of the
# corresponding R package 'ggplot2'. Please refer to the termpaper for a more
# detailed explanation of the code. 
# -----------------------------------------------------------------------------

# Source Testing Quantlet (automatically sources VaR &amp; CVaR and Data Prep. 
# Quantlets)
# Takes about 16 minutes
source("Quantlet3/Testing_Quantlet.R")

# Install and load packages
libraries = c("ggplot2", "metRology", "grid", "gridExtra")
lapply(libraries, function(x) 
  if (!(x %in% installed.packages())) {
    install.packages(x)
  }
)
lapply(libraries, library, quietly = TRUE, character.only = TRUE)

# -----------------------------------------------------------------------------
# 1. Plots for VaR &amp; CVaR Quantlet
# -----------------------------------------------------------------------------
# Specifiy mean and standard deviation of given log-returns
sd_pf   = sd(input.pf$Returns)
mean_pf = mean(input.pf$Returns)

# ---------------------------------------------------------------------------
# 1.1 Plots for Analytical VaR and CVaR (normal and Student's t-distribution)
# ---------------------------------------------------------------------------

# Define function for plotting analytical densities (normal and Student's t) 
# with corresponding VaRs and CVaRs  
# Arguments: distr (type of distribution - 'normal' or 't'), val.VaR 
# (calculated VaR for specified distribution), val.CVaR 
# (calculated CVaR for specified distribution), pos.labelVaR and pos.labelCVaR
# (position factor for VaR and CVaR labels, df (degrees of freedom), 
# plot.title (default = "")
# Output: No explicit output; plot is automatically displayed
Analyt.plot = function(distr, val.VaR, val.CVaR, pos.labelVaR, pos.labelCVaR, 
                       df = NA, plot.title = "") {
  if (missing(distr) | !(distr %in% c("normal", "t"))) {
    stop("Need to specify distr = 'normal' or 't' for plotting")
  } else if (missing(val.VaR) | !is.numeric(val.VaR)) {
    stop("Need to specify val.VaR as a numeric value for plotting")
  } else if (missing(val.CVaR) | !is.numeric(val.CVaR)) {
    stop("Need to specify val.CVaR as a numeric value for plotting")
  } else if (distr == "t" &amp; (missing(df) | df &lt;= 0)) {
    stop("Need to specify df &gt; 0 for t-distribution")
  } else {
    x      = seq(-0.07, 0.07, length = 500) # x-coordinates  
    if (distr == "normal") {
      # y-coordinates for normal distribution
      y      = dnorm(x, mean_pf, sd_pf)        # y-coordinates of given x 
      y.VaR  = dnorm(val.VaR, mean_pf, sd_pf)  # y-coordinate of VaR 
      y.CVaR = dnorm(val.CVaR, mean_pf, sd_pf) # y-coordinate of CVaR
    } else {
      # y-coordinates for non-standard Student's t-distribution
      y      = dt.scaled(x, df, mean_pf, sd_pf * sqrt((df - 2) / df))
      y.VaR  = dt.scaled(val.VaR, df, mean_pf, sd_pf * sqrt((df - 2) / df))
      y.CVaR = dt.scaled(val.CVaR, df, mean_pf, sd_pf * sqrt((df - 2) / df))
    }
    # Create dataframe with calulated x- and y-coordinates
    dat = data.frame(x, y)
    
    ggplot(data = dat, mapping = aes(x = x, y = y)) +
      geom_line() +                 # Connect points with line
      xlab("Daily Log-Returns") +   # Add x-axis label
      ylab("Density") +             # Add y-axis label
      ggtitle(label = plot.title) + # Add plot title
      # Add vertical lines indicating VaR and CVaR
      geom_segment(aes(x = val.VaR, y = 0, xend = val.VaR, yend = y.VaR)) +
      geom_segment(aes(x = val.CVaR, y = 0, xend = val.CVaR, yend = y.CVaR)) +
      # Add corresponding VaR and CVaR as labels
      annotate("text", x = val.VaR * pos.labelVaR, y = y.VaR, 
               label = paste("VaR =", round(val.VaR, 3)), size = 4) + 
      annotate("text", x = val.CVaR * pos.labelCVaR, y = y.CVaR, 
               label = paste("CVaR =", round(val.CVaR, 3)), size = 4) +
      # Create yellow area under the curve from -Inf to VaR
      geom_area(mapping = aes(x = ifelse(x &lt;= val.VaR, x, val.VaR), y = y),
                fill = "yellow", alpha = 0.3) +
      # Scale the whole plot between 0 and the greatest y-value
      scale_y_continuous(limits = c(0, max(dat$y))) +
      # Adjust plot format
      theme(text = element_text(size = 13, color = "black"), 
            plot.title = element_text(hjust = 0.5),
            axis.text.x = element_text(color = "black"),
            axis.text.y = element_blank(),  # Delete axis values of y-axis
            axis.ticks.y = element_blank(), # Delete axis ticks of y-axis
            panel.background = element_rect(fill = "white", colour = NA),
            axis.line.x = element_line(color = "black", 
                                       arrow = arrow(length = unit(0.25, "cm"))), 
            axis.line.y = element_line(color = "black", 
                                       arrow = arrow(length = unit(0.25, "cm"))))
  }
}

# Analytical VaR and CVaR under normal and t-distribution

# Save Plot into a pdf 
pdf("Quantlet5/Analytical VaR &amp; CVaR under normal and t-distribution.pdf", 
    width = 10, height = 5)

# Specifications for the function call of Analyt.plot 
distr      = list("normal", "t")
VaR        = list(Analyt.VaR[1], Analyt.VaR[2])
CVaR       = list(Analyt.CVaR[1], Analyt.CVaR[2])
pos.VaR    = c(2.15, 2.25)
pos.CVaR   = c(2.05, 2)
df         = list(NA, 4)
plot.title = c("Normal distribution", "Student's t-distribution")

# The Analyt.plot function is called two times and the resulting plots are arranged 
# in a matrix with two columns and one row
do.call(grid.arrange, c(lapply(1:length(distr), function(x) 
        Analyt.plot(distr[[x]], VaR[[x]], CVaR[[x]], pos.VaR[x], 
        pos.CVaR[x], df[[x]], plot.title[x])), ncol = 2))
dev.off()

# -------------------------------------------------------------------------------
# 1.2 Plots for VaR and CVaR of Monte Carlo Simulation and Historical Simulation
# -------------------------------------------------------------------------------

# Define function for plotting empirical densities (historical and Monte Carlo) 
# with corresponding VaRs and CVaRs  
# Arguments: dat (historical log-returns or MC simulated log-returns), val.VaR 
# (calculated VaR for specified data), val.CVaR 
# (calculated CVaR for specified data), pos.labelVaR and pos.labelCVaR
# (position factor for VaR and CVaR labels, plot.title (default = "")
# Output: No explicit output; plot is automatically displayed
Emp.plot = function(dat, val.VaR, val.CVaR, pos.labelVaR, pos.labelCVaR, 
                    plot.title = "") {
    if (missing(dat)) {
      stop("Need to specify the data of log-returns for plotting")
    } else if (missing(val.VaR) | !is.numeric(val.VaR)) {
      stop("Need to specify val.VaR as a numeric value for plotting")
    } else if (missing(val.CVaR) | !is.numeric(val.CVaR)) {
      stop("Need to specify val.CVaR as a numeric value for plotting")
    } else {
      # Estimate the density of the given data using the 
      # Kernel density estimator with gaussian kernel function
      dens      = density(dat)
      dat.plot  = data.frame(x = dens$x, y = dens$y)
      # approxfun() interpolates all points between the given 
      # observations of dat.plot
      func.dens = approxfun(dens)
      
      ggplot(data = dat.plot, mapping = aes(x = x, y = y)) +
        geom_line() +                 # Connect points with line
        xlab("Daily Log-Returns") +   # Add x-axis label
        ylab("Density") +             # Add y-axis label
        ggtitle(label = plot.title) + # Add plot title
        # Add vertical lines indicating VaR and CVaR
        geom_segment(aes(x = val.VaR, y = 0, xend = val.VaR, 
                     yend = func.dens(val.VaR))) +
        geom_segment(aes(x = val.CVaR, y = 0, xend = val.CVaR, 
                     yend = func.dens(val.CVaR))) +
        # Add corresponding VaR and CVaR as labels
        annotate("text", x = val.VaR * pos.labelVaR, y = func.dens(val.VaR), 
                 label = paste("VaR =", round(val.VaR, 3)), size = 4) + 
        annotate("text", x = val.CVaR * pos.labelCVaR, y = func.dens(val.CVaR), 
                 label = paste("CVaR =", round(val.CVaR, 3)), size = 4) +
        # Create yellow area under the curve from -Inf to VaR
        geom_area(mapping = aes(x = ifelse(x &lt;= val.VaR, x, val.VaR), y = y),
                  fill = "yellow", alpha = 0.3) +
        # Scale the whole plot between 0 and the greatest y-value
        scale_y_continuous(limits = c(0, max(dat.plot$y))) +
        # Adjust plot format
        theme(text = element_text(size = 13, color = "black"),
              plot.title = element_text(hjust = 0.5),
              axis.text.x = element_text(color = "black"),
              axis.text.y = element_blank(),  # Delete axis values of y-axis
              axis.ticks.y = element_blank(), # Delete axis ticks of y-axis
              panel.background = element_rect(fill = "white", colour = NA),
              axis.line.x = element_line(color = "black", 
                                         arrow = arrow(length = unit(0.25, "cm"))), 
              axis.line.y = element_line(color = "black", 
                                         arrow = arrow(length = unit(0.25, "cm"))))
    }
}

# Monte Carlo VaR and CVaR under normal and t-distribution
# Save Plot into a pdf 
pdf("Quantlet5/MC VaR &amp; CVaR under normal and t-distribution.pdf", 
    width = 10, height = 5)

# Specifications for the function call of Emp.plot 
dat        = list(MC.VaR$MC_data_norm, MC.VaR$MC_data_t)
VaR        = list(MC.VaR[[2]], MC.VaR[[4]])
CVaR       = list(MC.CVaR[[2]], MC.CVaR[[4]])
pos.VaR    = c(1.65, 3.1)
pos.CVaR   = c(1.6, 2.6)
plot.title = c("Normal distribution", "Student's t-distribution")

# The Emp.plot function is called two times and the resulting plots are arranged 
# in a matrix with two columns and one row
do.call(grid.arrange, c(lapply(1:length(dat), function(x) 
        Emp.plot(dat[[x]], VaR[[x]], CVaR[[x]], pos.VaR[x], 
        pos.CVaR[x], plot.title[x])), ncol = 2))
dev.off()

# Unweighted and weighted log-returns and corresponding historical 
# VaRs and CVaRs 
# Save Plot into a pdf 
pdf("Quantlet5/Historical VaR &amp; CVaR with equally and differently weighted returns.pdf", 
    width = 10, height = 5)

# Specifications for the function call of Emp.plot 
dat        = list(input.pf$Returns, input.pf$Returns)
VaR        = list(Hist.VaR[1], Hist.VaR[2])
CVaR       = list(Hist.CVaR[1], Hist.CVaR[2])
pos.VaR    = c(2, 2)
pos.CVaR   = c(1.85, 1.85)
plot.title = c("Equally weighted returns", "Differently weighted returns")

# The Emp.plot function is called again two times and the resulting 
# plots are arranged in a matrix with two columns and one row
do.call(grid.arrange, c(lapply(1:length(dat), function(x) Emp.plot(dat[[x]],
        VaR[[x]], CVaR[[x]], pos.VaR[x], pos.CVaR[x], plot.title[x])), ncol = 2))
dev.off()

# -----------------------------------------------------------------------------
# 2. Plots for Testing Quantlet
# -----------------------------------------------------------------------------

# --------------------------------------------------
# 2.1 Plots for visualization of distribution tests
# --------------------------------------------------
set.seed(333)
# Define function for plotting two distributions in order to compare them
# Arguments: data1 (first data to compare), name_distrbution1 (name of first
# distribution), data2 (second data to compare), name_distrbution2 (name of
# second distribution)
# Output: No explicit output; plot is automatically displayed
plot.distribution = function(data1, name_distrbution1, data2, name_distrbution2) {
    if (missing(data1) | missing(data2)) {
      stop("Need to specify both data1 and data2 for plotting")
    } else if (missing(name_distrbution1) | missing(name_distrbution2)) {
      stop("Need to specify the distribution names of both 
           distributions for plotting")
    } else {
      df = data.frame(x = c(data1, data2), Cum.Distrib. = c(rep(name_distrbution1, 
                      length(data1)), rep(name_distrbution2, length(data2))))

      ggplot(df, aes(x, colour = Cum.Distrib.)) + stat_ecdf() +
        xlab("Quantile") + # Add x-axis label
        # Adjust plot format
        theme(legend.justification = c(1, 0.2), legend.position = c(1, 0.2), 
              text = element_text(size = 13, color = "black"), 
              axis.text.x = element_text(color = "black"),
              panel.background = element_rect(fill = "white", colour = NA),
              axis.line.x = element_line(color = "black", 
                                         arrow = arrow(length = unit(0.25, "cm"))), 
              axis.line.y = element_line(color = "black", 
                                         arrow = arrow(length = unit(0.25, "cm"))))
    }
}

# Create one matrix containing all plots resulting from 
# plot.distribution function and save it to a pdf 
pdf("Quantlet5/Distribution.pdf", width = 10, height = 10)
data1        = list(hist, hist, mc_data_norm, mc_data_norm, mc_data_t, 
                    mc_data_t, mc_data_norm, mc_data_t)
names(data1) = c("Hist. data", "Hist. data", 
                 "MC data (normal)", "MC data (normal)", 
                 "MC data (t)","MC data (t)", 
                 "MC data (normal)", "MC data (t)")

data2        = list(rnorm(100 * length(hist), mean(hist), sd(hist)), 
                    rt(length(hist), 4) * sd(hist) / sqrt(2) + mean(hist),
                    rnorm(length(mc_data_norm), mean(mc_data_norm), 
                          sd(mc_data_norm)),
                    rt(length(mc_data_norm), 4) * sd(mc_data_norm) / sqrt(2) + 
                    mean(mc_data_norm),
                    rnorm(length(mc_data_t), mean(mc_data_t), sd(mc_data_t)),
                    rt(length(mc_data_t), 4) * sd(mc_data_t) / sqrt(2) + 
                    mean(mc_data_t), hist, hist)
names(data2) = c("Normal", "Student´s t", "Normal", "Student´s t", 
                 "Normal", "Student´s t", "Hist. data", "Hist. data")
do.call(grid.arrange, c(lapply(1:length(data1), function(x) 
        plot.distribution(data1[[x]],names(data1)[x], data2[[x]], 
        names(data2)[x])), ncol = 2))
dev.off()

# --------------------------------------------------------------------------
# 2.2 Plots for visualization of VaR tests
# --------------------------------------------------------------------------

# Define function for plotting results of the cTestData function (line 371 
# of Testing quantlet) for the Kupiec Test (VaRTest)
# Arguments: dat (output data of cTestData function), VaR (vector of VaRs 
# resulting from cTestData function), plot.title (default = "")
# Output: No explicit output; plot is automatically displayed
plot.VaRTest = function(dat, VaR, plot.title = "") {
  if (missing(dat) | missing(VaR)) {
    stop("Need to specify both dat and VaR for plotting")
  } else {
    plot = ggplot(dat, aes(x = Date, y = PnL))
    plot + geom_bar(stat = "identity") +       # Create a bar plot
           ylab("Daily Log-Returns (hist.)") + # Add y-axis label
           ggtitle(label = plot.title) +       # Add plot title
           # Add daily estimated VaR as red points to the plot
           geom_point(aes(x = Date, y = VaR), size = 2, shape = 45, 
                      color = "red") +
           # Adjust plot format
           theme(text = element_text(size = 13, color = "black"), 
                 plot.title = element_text(hjust = 0.5),
                 axis.text.x = element_blank(), 
                 axis.text.y = element_text(color = "black"), 
                 axis.ticks.x = element_blank(), 
                 axis.line.y = element_line(color = "black"))
  }
}

# Create matrix containing plots concerning MC Simulation 
# resulting from plot.VaRTest function and save it to a pdf 
pdf("Quantlet5/VaRTest_MC.pdf", width = 6, height = 10)
data       = list(VarTest.dat.mcnorm$Test.data, VarTest.dat.mct$Test.data)
VaR        = list(VarTest.dat.mcnorm$Test.data$VAR, VarTest.dat.mct$Test.data$VAR)
plot.title = c("Monte Carlo Sim. (Normal distribution)",
               "Monte Carlo Sim. (Student´s t-distribution)")
do.call(grid.arrange, c(lapply(1:length(data), function(x) 
        plot.VaRTest(data[[x]], VaR[[x]], plot.title[x])), ncol = 1))
dev.off()

# Create matrix containing plots concerning Historical Simulation
# resulting from plot.VaRTest function and save it to a pdf 
pdf("Quantlet5/VaRTest_hist.pdf", width = 6, height = 10)
data       = list(VarTest.dat.hist$Test.data, VarTest.dat.hist_w$Test.data)
VaR        = list(VarTest.dat.hist$Test.data$VAR, VarTest.dat.hist_w$Test.data$VAR)
plot.title = c("Historical Simulation (unweighted)",
               "Historical Simulation (weighted)")
do.call(grid.arrange, c(lapply(1:length(data), function(x) 
        plot.VaRTest(data[[x]], VaR[[x]], plot.title[x])), ncol = 1))
dev.off()

# Create matrix containing plots for Analytical Models
# resulting from plot.VaRTest function and save it to a pdf 
pdf("Quantlet5/VaRTest_ana.pdf", width = 6, height = 10)
data       = list(VarTest.dat.ananorm$Test.data, VarTest.dat.anat$Test.data, 
                  VarTest.dat.anacf$Test.data)
VaR        = list(VarTest.dat.ananorm$Test.data$VAR, VarTest.dat.anat$Test.data$VAR, 
                  VarTest.dat.anacf$Test.data$VAR)
plot.title = c("Analytical model (Normal distribution)",
               "Analytical model (Student´s t-distribution)",
               "Analytical model (Cornish-Fisher Expansion)")
do.call(grid.arrange, c(lapply(1:length(data), function(x) 
        plot.VaRTest(data[[x]], VaR[[x]], plot.title[x])), ncol = 1))
dev.off()

# ------------------------------------------------------------------------
# 2.3 Plots for visualization of CVaR tests
# ------------------------------------------------------------------------

# Define function for plotting results of the cTestData function (line 371 
# of Testing quantlet) for the McNeil &amp; Frey Test (ESTest)
# Arguments: dat (output data of cTestData function), VaR (vector of VaRs 
# resulting from cTestData function), CVaR (vector of CVaRs 
# resulting from cTestData function), plot.title (default = "")
# Output: No explicit output; plot is automatically displayed
plot.ESTest = function(dat, VaR, CVaR, plot.title = "") {
  if (missing(dat) | missing(VaR) | missing(CVaR)) {
    stop("Need to specify dat, VaR and CVaR for plotting")
  } else {
    # Keep only those observations where the estimated VaR is exceeded
    dat_ex  = dat[VaR &gt; PnL, ]
    PnL_ex  = PnL[VaR &gt; PnL]
    Date_ex = dat$Date[VaR &gt; PnL]
    CVaR_ex = CVaR[VaR &gt; PnL]
    
    # Plot log-returns and corresponding estimated CVaR (red) where the 
    # estimated VaR was exceeded
    plot = ggplot(dat_ex, aes(x = Date_ex, y = PnL_ex))
    plot + geom_bar(stat = "identity") +                 # Create a bar plot
           xlab("Days with VaR exceedances") +           # Add x-axis label
           ylab("Daily Log-Returns for exceeded VaRs") + # Add y-axis label
           ggtitle(label = plot.title) +                 # Add plot title
           # Add daily estimated CVaR as red lines to the plot
           geom_point(aes(x = Date_ex, y = CVaR_ex), size = 5, 
                      shape = 45, color = "red") +
           # Adjust plot format
           theme(text = element_text(size = 13, color = "black"), 
                 plot.title = element_text(hjust = 0.5),
                 panel.background = element_rect(fill = "white", colour = NA),
                 axis.text.x = element_blank(), 
                 axis.text.y = element_text(color = "black"), 
                 axis.ticks.x = element_blank(), 
                 axis.line.y = element_line(color = "black"))
  }
}

# Create matrix containing plots concerning MC Simulation
# resulting from plot.ESTest function and save it to a pdf 
pdf("Quantlet5/CVaRTest_MC.pdf", width = 6, height = 10)
data       = list(VarTest.dat.mcnorm$Test.data, VarTest.dat.mct$Test.data)
VaR        = list(VarTest.dat.mcnorm$Test.data$VAR, VarTest.dat.mct$Test.data$VAR)
CVaR       = list(VarTest.dat.mcnorm$Test.data$CVAR, VarTest.dat.mct$Test.data$CVAR)
plot.title = c("Monte Carlo model (Normal distribution)",
               "Monte Carlo model (Student´s t-distribution)")
do.call(grid.arrange, c(lapply(1:length(data), function(x) 
        plot.ESTest(data[[x]], VaR[[x]], CVaR[[x]], 
        plot.title[x])), ncol = 1))
dev.off()

# Create matrix containing plots concerning Historical Simulation
# resulting from plot.ESTest function and save it to a pdf 
pdf("Quantlet5/CVaRTest_hist.pdf", width = 6, height = 10)
data       = list(VarTest.dat.hist$Test.data, VarTest.dat.hist_w$Test.data)
VaR        = list(VarTest.dat.hist$Test.data$VAR, VarTest.dat.hist_w$Test.data$VAR)
CVaR       = list(VarTest.dat.hist$Test.data$CVAR, VarTest.dat.hist_w$Test.data$CVAR)
plot.title = c("Historical Simulation (unweighted)",
               "Historical Simulation (weighted)")
do.call(grid.arrange, c(lapply(1:length(data), function(x) 
        plot.ESTest(data[[x]], VaR[[x]], CVaR[[x]], 
        plot.title[x])), ncol = 1))
dev.off()

# Create matrix containing plots for Analytical Models
# resulting from plot.ESTest function and save it to a pdf 
pdf("Quantlet5/CVaRTest_ana.pdf", width = 6, height = 10)
data       = list(VarTest.dat.ananorm$Test.data, VarTest.dat.anat$Test.data, 
                  VarTest.dat.anacf$Test.data)
VaR        = list(VarTest.dat.ananorm$Test.data$VAR, VarTest.dat.anat$Test.data$VAR, 
                  VarTest.dat.anacf$Test.data$VAR)
CVaR       = list(VarTest.dat.ananorm$Test.data$CVAR, VarTest.dat.anat$Test.data$CVAR, 
                  VarTest.dat.anacf$Test.data$CVAR)
plot.title = c("Analytical model (Normal distribution)",
               "Analytical model (Student´s t distribution)",
               "Analytical model (Cornish-Fisher Expansion)")
do.call(grid.arrange, c(lapply(1:length(data), function(x) 
        plot.ESTest(data[[x]], VaR[[x]], CVaR[[x]], 
        plot.title[x])), ncol = 1))
dev.off()

# -----------------------------------------------------------------------------
# 3. Plots for Portfolio Optimization Quantlet
# -----------------------------------------------------------------------------
# source Portfolio Optimization Quantlet 
source("Quantlet4/PortfolioOptimization.R")

# Define function for plotting the mu-sigma diagram incl. efficient frontiers
# for a given portfolio
# Argument: risk.measure (VaR or CVaR)
# Output: plot of gererated mu-sigma diagram incl. efficient frontiers
plot.PortOpt = function(risk.measure = "VaR") {
    plot = ggplot(data.frame(ER = er.rf.eff.front, SD = sd.rf.eff.front), 
                  aes(SD, ER)) +
             # eff.frontier incl. risk free asset
             geom_path(aes(SD, ER, colour = ER &gt;= rf, linetype = ER &gt;= rf, 
                           size = ER &gt;= 0, alpha = ER &gt;= 0)) + 
             # eff.frontier excl. risk free asset
             geom_path(aes(x = SD, y = ER, 
                           col = ER &gt;= wmv(Return_First_Year)[2], 
                           linetype = ER &gt;= wmv(Return_First_Year)[2], 
                           size = ER &gt;= wmv(Return_First_Year)[2], 
                           alpha = ER &gt;= wmv(Return_First_Year)[2]), 
                       data.frame(ER = er.eff.front, SD = sd.eff.front)) + 
             # Add the optimized portfolio and label it
             geom_point(aes(x = SD, y = ER), data = OPF) +
             geom_label(label = "Opt. PF", aes(x = SD, y = ER, hjust = .5, 
                                               vjust = -0.15), data = OPF) +
             # Add the initial portfolio and label it
             geom_point(aes(x = SD, y = ER), data = MPF) +
             geom_label(label ="Start PF", aes(x = SD, y = ER, hjust = -0.05, 
                                               vjust = 0.5), data = MPF) +
             # Formats the conditional linetype and colour
             scale_colour_manual(name = "wmv(Return_First_Year)[2]", 
                                 values = setNames(c("darkgreen", 
                                                     "firebrick1"), c(T, F))) +
             scale_linetype_manual(name = "ER &gt;= wmv(Return_First_Year)[2]", 
                                   values = setNames(c(1, 2), c(T, F))) +
             scale_size_manual(name = "ER &gt;= wmv(Return_First_Year)[2]", 
                               values = setNames(c(1.2, 0.5), c(T, F))) +
             scale_alpha_manual(name = "ER &gt;= wmv(Return_First_Year)[2]", 
                                values = setNames(c(1, 0.5), c(T, F))) +
             # Adjust plot format
             theme(legend.position = "none", panel.background = element_blank(),
                   axis.line.x = element_line(color = "black", 
                                              arrow = arrow(length = unit(0.25, 
                                                                          "cm"))),
                   axis.line.y = element_line(color = "black", 
                                              arrow = arrow(length = unit(0.25, 
                                                                          "cm")))) + 
             xlab("Standard Deviation") + ylab("Expected Return") +
             # Define the displayed are of the x and y axis
             scale_x_continuous(limits = c(0, 0.5)) +
             scale_y_continuous(limits = c(-0.3, 0.7))
    
    # Add addiotional linear risk constraint
    if (risk.measure == "VaR") {
      plot = plot + geom_path(aes(x = SD, y = ER), data.frame(ER = VAR[2], 
                                                              SD = VAR[1])) + # Var.C
                    geom_label(label = "VaR Constraint", aes(x = SD, y = ER, 
                                                             hjust = -0.05, vjust = 1), 
                               data = data.frame(ER = -cv, SD = 0))
    } else if (risk.measure == "CVaR") {
      plot = plot + geom_path(aes(x = SD, y = ER), data.frame(ER = CVAR[2], 
                                                              SD = CVAR[1])) + # CVar.C
                    geom_label(label = "CVaR Constraint", aes(x = SD, y = ER, 
                                                              hjust = -0.05, vjust = 1), 
                               data = data.frame(ER = -cv, SD = 0))
    } else { 
      stop("Need to specify risk.measure ('VaR' or 'CVaR').")
    }
    return(plot)
}

# Create mu-sigma diagram incl. efficient frontiers for given portfolio
# resulting from plot.PortOpt function and save it to a pdf 
pdf("Quantlet5/Portfolio_Optimization_Plot.pdf", width = 7, height = 5)
plot.PortOpt(risk.measure = lc) #lc = 'CVaR' (see Portfolio Optimization quantlet)
dev.off()

# Plot development of portfolio weights
# Define function for plotting the development of portfolio weights for
# given portfolio
# Argument: x (a data.frame containing the Dates, Symbols and Weights), 
# y (vector containing the Strategies Name)
# Output: No explicit output; plot is automatically displayed
plot.Weights = function(x, y) {
    if (missing(x) | colnames(x)[1] != "Date" | 
        colnames(x)[2] != "Symbol" | colnames(x)[3] != "Weights") {
      stop("Need to specify a dataset for x with colums Date, Symbol and Weights")
    } else {
      ggplot(x, aes(x = Date, y = Weights, fill = Symbol, width = 3)) + 
        geom_bar(stat = "identity") +
        theme(panel.background = element_blank(), 
              axis.ticks.x = element_blank(),
              axis.line.x = element_line(color = "black", 
                                         arrow = arrow(length = unit(0.25, "cm"))),
              axis.line.y = element_line(color = "black", 
                                         arrow = arrow(length = unit(0.25, "cm"))),
              axis.text.y = element_text(size = 6), 
              legend.key.size = unit(0.4, "cm")) + 
        xlab("Date") + 
        ylab(paste("Weights of", gsub("_1", "", y, perl = TRUE)))
    }
}

# Create matrix containing plots of the development of portfolio weights
# resulting from plot.Weights function and save it to a pdf 
pdf("Quantlet5/Portfolio_Weights.pdf", width = 7, height = 5)
strategies        = list(NormPF_1, RegularPF_1, OptPF_1)
names(strategies) = c("NormPF_1", "RegularPF_1", "OptPF_1")
do.call(grid.arrange, c(lapply(1:length(strategies), function(x) 
        plot.Weights(strategies[[x]], names(strategies)[x])), ncol = 1))
dev.off()

# Plot portfolio value over time and save it to a pdf
date             = RegularPF_1$Date[RegularPF_1$Symbol == stocks[1]]
Overall.Val      = melt(Overall.Val)
Overall.Val$date = c(date, date, date)

# Using Overall.Val generate Plot containing all Strategies to display over time
pdf("Quantlet5/Portfolio_value_overTime.pdf", width = 7, height = 5)
ggplot(Overall.Val, aes(x = date, y = value, colour = variable)) + 
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color = "black", 
                                   arrow = arrow(length = unit(0.25, "cm"))),
        axis.line.y = element_line(color = "black", 
                                   arrow = arrow(length = unit(0.25, "cm")))) +
  xlab("Date") + ylab("Portfolios Net Liquidation Value") +
  geom_line() + guides(colour = guide_legend(title = "Strategy"))
dev.off()
